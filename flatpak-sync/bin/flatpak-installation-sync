#!/usr/bin/env bash

set -euo pipefail
set -x

PROG="$(basename "$BASH_SOURCE")"

cfg_tmp_dir="$(mktemp -d)"

_exit () {
	exit_code="${1:-99}"
	# Untrap exit signal to avoid looping
	trap - EXIT
	# Kill any direct descendents before exiting
	pkill -P $$ || :
	if [ -e "$cfg_tmp_dir" ]; then
		rm -r "$cfg_tmp_dir"
	fi
	exit "$exit_code"
}

trap '_exit 7' SIGINT SIGTERM SIGHUP
trap '_exit $?' EXIT

print_help () {
	cat <<EOF
Usage: $PROG [--file=CONFIG] COMMAND [OPTION...]

Automate flatpak installation.

Add flatpak repos and install a declarative list of flatpaks.
Uses the same format as bluebuild's default_flatpak module v2.

commands:
  init            initialize a config file
  install         install configured flatpaks

options:
  -f, --file CONFIG  config file to use (default: /usr/share/flatpak-sync/config.yaml)
  -h, --help       print usage information and exit
EOF
}


main() {
	# Requires gnu enhanced getopt
	ARGS=$(getopt --name "$PROG" --long 'help,file:' --options 'hf:' -- "$@")
	eval set -- "$ARGS"

	config_files=()

	while [ $# -gt 0 ]; do
		case "$1" in
			-h | --help)
				print_help
				exit 0
				;;
			-f | --file)
				shift
				config_files+=("$1")
				;;
			--)
				shift
				break
				;;
		esac
		shift
	done

	# Locate the user or system config to use
	if [ "${#config_files[@]}" -eq 0 ]; then
		default_config="$(determine_default_config)" || exit $?
		config_files+=("$default_config")
	fi

	case "$1" in
		install)
			cmd_install "${config_files[@]}" || exit $?
			;;
		init)
			cmd_init "${config_files[@]}" || exit $?
			;;
		*)
			echo "Unrecognized command \"$1\"" >&2
			exit 1
			;;
	esac

}

determine_default_config() {
	default_config="${XDG_CONFIG_HOME:-"$HOME"/.config}"/flatpak-sync/config.yaml
	if ! [ -e "$default_config" ]; then
		default_config="${XDG_CONFIG_HOME:-"$HOME"/.config}"/flatpak-sync/config.yml
	fi
	if ! [ -e "$default_config" ]; then
		default_config="${XDG_CONFIG_HOME:-"$HOME"/.config}"/flatpak-sync.yaml
	fi
	if ! [ -e "$default_config" ]; then
		default_config="${XDG_CONFIG_HOME:-"$HOME"/.config}"/flatpak-sync.yml
	fi
	if ! [ -e "$default_config" ]; then
		default_config=/etc/flatpak-sync/config.yaml
	fi
	if ! [ -e "$default_config" ]; then
		default_config=/usr/share/flatpak-sync/config.yaml
	fi
	if ! [ -e "$default_config" ]; then
		echo "No config file found, please specify" >&2
		return 5
	fi
	echo -n "$default_config"
}

# Ideally, we'd parse all of the configs, assemble a list of removals and adds, then apply that in one go
# That would be a lot easier in a real programming language, though

# Configure the repo and install flatpaks specified in a config file containing a single repo entry.
apply_config() {
	# Very janky yaml parsing - requires only receiving one list element and a reasonably well structured yaml
	config_file="$1"

	# Return early if there are no non-empty, non-comment lines
	if ! grep --quiet --invert-match -E '^[ '$'\t'']*(#.*)?$' "$config_file"; then
		return 0
	fi

	# "parse" the repo block
	remote_name="$(grep -E '^ *name: +' "$config_file" | sed -E -e 's/^ *name: +//' -e 's/ *(#.*)?$//')"
	remote_title="$(grep -E '^ *title: +' "$config_file" | sed -E -e 's/^ *title: +//' -e 's/ *(#.*)?$//')"
	remote_url="$(grep -E '^ *url: +' "$config_file" | sed -E -e 's/^ *url: +//' -e 's/ *(#.*)?$//')"
	remote_removed="$(grep -E '^ *remove: +' "$config_file" | sed -E -e 's/^ *remove: +//' -e 's/ *(#.*)?$//')"
	remote_scope="$(grep -E '^ *scope: +' "$config_file" | sed -E -e 's/^ *scope: +//' -e 's/ *(#.*)?$//')"

	if [ "${remote_removed,,}" = "user" ]; then
		remote_scope="user"
	else
		remote_scope="system"
	fi
	if [ "${remote_removed,,}" = "true" ] || [ "${remote_removed,,}" = "yes" ]; then
		remote_removed=true
	else
		remote_removed=false
	fi

	# Begin install parsing
	install=()
	do_match=false
	match_min_indent=''
	while IFS='' read -r line; do
		if echo "$line" | grep -E --quiet "^ *-? *install:"; then
			do_match=true
			match_min_indent="$(echo "$line" | sed -E -e 's/install:.*//' -e 's/-/ /')"
		elif "$do_match"; then
			if echo "$line" | grep -E --quiet "^ *(#.*)?$"; then
				:  # empty line or comment
			elif echo "$line" | grep -E --quiet "^$match_min_indent *-"; then
				flatpak="$(echo "$line" | sed -E -e "s/^$match_min_indent *- *//" -e 's/ *(#.*)?$//')"
				install+=("$flatpak")
			else
				do_match=false
				break
			fi
		fi
	done < "$config_file"
	# End install parsing

	# Begin uninstall parsing
	uninstall=()
	do_match=false
	match_min_indent=''
	while IFS='' read -r line; do
		if echo "$line" | grep -E --quiet "^ *-? *uninstall:"; then
			do_match=true
			match_min_indent="$(echo "$line" | sed -E -e 's/uninstall:.*//' -e 's/-/ /')"
		elif "$do_match"; then
			if echo "$line" | grep -E --quiet "^ *(#.*)?$"; then
				:  # empty line or comment
			elif echo "$line" | grep -E --quiet "^$match_min_indent *-"; then
				flatpak="$(echo "$line" | sed -E -e "s/^$match_min_indent *- *//" -e 's/ *(#.*)?$//')"
				uninstall+=("$flatpak")
			else
				do_match=false
				break
			fi
		fi
	done < "$config_file"
	# End uninstall parsing

	if [ -z "$remote_name" ]; then
		echo "Remote name not specified; please set remote.name for each flatpak remote" >&2
		return 1
	fi

	flatpak_cmd=(flatpak "--$remote_scope")

	remote_exists=false
	if "${flatpak_cmd[@]}" remotes --show-disabled --columns=name | tail -n +1 | grep --quiet --line-regexp --fixed-strings "$remote_name"; then
		remote_exists=true
	fi

	# Delete the remote and any sourced flatpaks if present
	if "$remote_removed"; then
		if ! $remote_exists; then
			return 0
		fi
		echo "Preparing to delete remote $remote_name"

		mapfile -t apps_to_uninstall < <("${flatpak_cmd[@]}" list --"$remote_scope"  --app --columns=origin,application,arch,branch | tail -n +1 | grep --fixed-strings "$remote_name"$'\t' | cut -f 2,3,4 | sed -E "s|\t|/|g")
		if [ "${#apps_to_uninstall[@]}" -gt 0 ]; then
			echo "Uninstalling apps ${apps_to_uninstall[*]} from remote $remote_name"
			"${flatpak_cmd[@]}" uninstall --noninteractive "${apps_to_uninstall[@]}"
		fi

		mapfile -t runtimes_to_uninstall < <("${flatpak_cmd[@]}" list --"$remote_scope" --runtime --columns=origin,application,arch,branch | tail -n +1 | grep --fixed-strings "$remote_name"$'\t' | cut -f 2,3,4 | sed -E "s|\t|/|g")
		if [ "${#runtimes_to_uninstall[@]}" -gt 0 ]; then
			echo "Uninstalling runtimes ${runtimes_to_uninstall[*]} from remote $remote_name"
			"${flatpak_cmd[@]}" uninstall --noninteractive "${runtimes_to_uninstall[@]}"
		fi

		echo "Removing remote $remote_name"
		"${flatpak_cmd[@]}" remote-delete "$remote_name"
		return 0
	fi

	# Add the remote if not present
	if ! "$remote_exists"; then
		if [ -z "$remote_name" ] || [ -z "$remote_title" ] || [ -z "$remote_url" ]; then
			echo "Remote info incomplete; name=$remote_name, title=$remote_title, url=$remote_url" >&2
			return 1
		fi
		echo "Adding $remote_scope remote $remote_name ($remote_title) at $remote_url"
		"${flatpak_cmd[@]}" remote-add --if-not-exists "$remote_name" --title="$remote_title" "$remote_url"
	fi

	if ! "${flatpak_cmd[@]}" remotes --columns=name | tail -n +1 | grep --quiet --fixed-strings "$remote_name"; then
		echo "Enable remote $remote_name"
		"${flatpak_cmd[@]}" remote-modify --enable "$remote_name"
	fi

	# Install any desired flatpaks
	if [ "${#install[@]}" -gt 0 ]; then
		"${flatpak_cmd[@]}" install --noninteractive "$remote_name" "${install[@]}"
	fi

	# Uninstall any flatpaks that are already installed from the given remote
	if [ "${#uninstall[@]}" -gt 0 ]; then
		mapfile -t to_uninstall < <(sort <("${flatpak_cmd[@]}" list --columns=origin,application | tail -n +1 | grep --fixed-strings "$remote_name"$'\t' | cut -f 2 | sort --unique) <(for installed_flatpak in "${uninstall[@]}"; do echo "$installed_flatpak"; done) | uniq -d)
		if [ "${#to_uninstall[@]}" -gt 0 ]; then
			"${flatpak_cmd[@]}" uninstall --noninteractive "$remote_name" "${to_uninstall[@]}"
		fi
	fi
	return 0
}

# concat config files together, then split per repo based on the expected yaml format
cmd_install() {
	config_files=("$@")
	repo_configs=()
	cat "${config_files[@]}" | csplit --digits=2 --quiet --prefix="$cfg_tmp_dir/repo" - "/^- /" "{*}" --elide-empty-files
	while IFS='' read -r f; do
		repo_configs+=("$f");
	done < <(find "$cfg_tmp_dir" -type f -name "repo*" | sort)
	for repo_config in "${repo_configs[@]}"; do
		apply_config "$repo_config"
	done
	return 0
}

cmd_init() {
	template_file="$1"
	if [ -s "$template_file" ]; then
		echo "$template_file already exists and is not empty!" >&2
		return 1
	fi
	cat <<'EOF' > "$template_file"
-  repo:
    name: flathub
    title: Flathub
    url: https://dl.flathub.org/repo/flathub.flatpakrepo
    remove: false  # optional, defaults to false; set to remove the remote and all flatpaks installed from the remote
  scope: system  # optional, defaults to system; configure system or user remotes and installs
  install:
  - org.gnome.Papers
  uninstall:
  - org.gnome.Evince
EOF
}

main "$@"
